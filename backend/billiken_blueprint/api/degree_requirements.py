import re
from sys import prefix
from venv import logger

from fastapi import APIRouter, HTTPException, Query
from pydantic import BaseModel

from billiken_blueprint.dependencies import (
    AuthPayload,
    CurrentStudent,
    DegreeRequirementsRepo,
    McCourseRepo,
    StudentRepo,
    SectionRepo,
    CourseRequirementsRepo,
)
from billiken_blueprint.domain.degree import Degree
from billiken_blueprint.domain.course import MinimalCourse
from billiken_blueprint.courses_at_slu.semester import Semester


router = APIRouter(prefix="/degree-requirements", tags=["degree-requirements"])


@router.get("")
async def get_degree_requirements(
    student: CurrentStudent,
    reqs_repo: DegreeRequirementsRepo,
    courses_repo: McCourseRepo,
):
    courses = await courses_repo.get_all()
    degree_reqs = reqs_repo.get(
        major=student.major_code,
        degree_type=student.degree_type,
        college=student.college,
    )
    if degree_reqs is None:
        logger.error(
            f"Degree requirements not found for {student.major_code} {student.degree_type} in {student.college}"
        )
        raise HTTPException(status_code=404, detail="Degree requirements not found")
    return [
        {
            "label": dr.label,
            "needed": dr.needed,
            "satisfyingCourseCodes": list(
                f"{mc.major_code} {mc.course_number}"
                for mc in dr.course_group.filter_satisfying_courses(courses)
            ),
        }
        for dr in degree_reqs
    ]


class SectionResponse(BaseModel):
    """Response model for a section."""

    id: int | None
    crn: str
    instructorNames: list[str]
    campusCode: str
    description: str
    title: str
    courseCode: str
    semester: str
    meetingTimes: list[dict]
    requirementLabel: str | None = (
        None  # Which degree requirement this section fulfills
    )


class AutoScheduleResponse(BaseModel):
    """Response model for autogenerated schedule."""

    sections: list[SectionResponse]
    requirementsCovered: int
    totalRequirements: int


@router.get("/autogenerate-schedule", response_model=AutoScheduleResponse)
async def autogenerate_schedule(
    student: CurrentStudent,
    reqs_repo: DegreeRequirementsRepo,
    courses_repo: McCourseRepo,
    sections_repo: SectionRepo,
    course_reqs_repo: CourseRequirementsRepo,
    semester: str = Query(
        Semester.SPRING, description="Semester code (e.g., '202501' for Spring 2025)"
    ),
    limit: int = Query(
        6, ge=1, le=10, description="Maximum number of sections to suggest"
    ),
    major_balance: float = Query(
        1,
        ge=0.0,
        le=1.0,
        description="Proportion of major vs university core requirements (0.0-1.0). 0.5 = 50/50, 0.7 = 70% major",
    ),
):
    """
    Generate an autogenerated schedule for the student that maximizes degree requirement coverage.

    This endpoint:
    - Finds all unsatisfied degree requirements
    - Suggests sections that cover as many different requirements as possible
    - Balances suggestions between major and university core requirements based on major_balance
    - Prioritizes sections with met prerequisites
    - Ensures no time conflicts between suggested sections
    - Returns up to `limit` sections

    Args:
        student: Current authenticated student
        semester: Semester code (e.g., "202501")
        limit: Maximum number of sections to return (default: 6, max: 10)
        major_balance: Proportion of major requirements (0.0-1.0). Default 0.5 = 50% major, 50% core.
                      0.7 = 70% major, 30% core. If all core requirements are satisfied, uses major only.

    Returns:
        AutoScheduleResponse with suggested sections and coverage statistics
    """

    # Get degree requirements
    degree_reqs = reqs_repo.get(
        major=student.major_code,
        degree_type=student.degree_type,
        college=student.college,
    )

    if degree_reqs is None:
        logger.error(
            f"Degree requirements not found for {student.major_code} {student.degree_type} in {student.college}"
        )
        raise HTTPException(
            status_code=404,
            detail=f"Degree requirements not found for {student.major_code} {student.degree_type} in {student.college}",
        )

    # Build Degree object
    degree = Degree(
        name=f"{student.major_code} {student.degree_type}", requirements=degree_reqs
    )

    # Get all courses to build the completed courses list
    all_courses = await courses_repo.get_all()
    courses_by_id = {
        course.id: course for course in all_courses if course.id is not None
    }

    # Build list of completed courses as MinimalCourse objects
    courses_taken: list[MinimalCourse] = []
    for course_id in student.completed_course_ids:
        if course_id in courses_by_id:
            course = courses_by_id[course_id]
            courses_taken.append(course)

    # Get all available sections for the semester
    all_sections = await sections_repo.get_all_for_semester(semester)
    all_sections = [
        section
        for section in all_sections
        if section.campus_code == "North Campus (Main Campus)"
    ]

    if not all_sections:
        logger.error(f"No sections found for semester {semester}")
        raise HTTPException(
            status_code=404, detail=f"No sections found for semester {semester}"
        )

    # Build prerequisites map
    course_prerequisites_map = {}
    unique_course_codes = set(section.course_code for section in all_sections)

    for course_code in unique_course_codes:
        prereqs = course_reqs_repo.get_for_code(course_code)
        course_prerequisites_map[course_code] = prereqs

    # Get suggested sections using the new function
    suggested_sections = degree.suggest_sections_maximizing_requirements(
        all_sections=all_sections,
        courses_taken=courses_taken,
        course_prerequisites_map=course_prerequisites_map,
        semester=semester,
        limit=limit,
        major_balance=major_balance,
    )

    # Count how many requirements are covered
    requirements_covered = 0
    for requirement in degree.requirements:
        if requirement.is_satisfied_by(courses_taken):
            continue  # Already satisfied

        # Check if any suggested section satisfies this requirement
        for section_with_req in suggested_sections:
            parts = section_with_req.section.course_code.split()
            if len(parts) == 2:
                temp_course = MinimalCourse(
                    id=None,
                    major_code=parts[0],
                    course_number=parts[1],
                    attributes=[],
                )
                if requirement.course_group.is_satisfied_by(temp_course):
                    requirements_covered += 1
                    break

    total_requirements = len(
        [req for req in degree.requirements if not req.is_satisfied_by(courses_taken)]
    )

    # Convert sections to response format
    section_responses = [
        SectionResponse(
            id=section_with_req.section.id,
            crn=section_with_req.section.crn,
            instructorNames=section_with_req.section.instructor_names,
            campusCode=section_with_req.section.campus_code,
            description=section_with_req.section.description,
            title=section_with_req.section.title,
            courseCode=section_with_req.section.course_code,
            semester=section_with_req.section.semester,
            requirementLabel=section_with_req.requirement_label,
            meetingTimes=[
                {
                    "day": mt.day,
                    "startTime": mt.start_time,
                    "endTime": mt.end_time,
                }
                for mt in section_with_req.section.meeting_times
            ],
        )
        for section_with_req in suggested_sections
    ]

    return AutoScheduleResponse(
        sections=section_responses,
        requirementsCovered=requirements_covered,
        totalRequirements=total_requirements,
    )
